<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Atelier — Smithy for Rust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="atelier.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/smithy.html"><strong aria-hidden="true">1.1.</strong> Smithy Overview</a></li><li class="chapter-item expanded "><a href="introduction/crates.html"><strong aria-hidden="true">1.2.</strong> Crate structure</a></li></ol></li><li class="chapter-item expanded "><a href="using/creating.html"><strong aria-hidden="true">2.</strong> Creating Models</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="using/model_api.html"><strong aria-hidden="true">2.1.</strong> Using the Model API</a></li><li class="chapter-item expanded "><a href="using/builder_api.html"><strong aria-hidden="true">2.2.</strong> Using the Builder API</a></li><li class="chapter-item expanded "><a href="using/visitor.html"><strong aria-hidden="true">2.3.</strong> Using the Visitor API</a></li></ol></li><li class="chapter-item expanded "><a href="using/io.html"><strong aria-hidden="true">3.</strong> Model IO</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="using/reader.html"><strong aria-hidden="true">3.1.</strong> Model Reader</a></li><li class="chapter-item expanded "><a href="using/writer.html"><strong aria-hidden="true">3.2.</strong> Model Writer</a></li><li class="chapter-item expanded "><a href="using/assembly.html"><strong aria-hidden="true">3.3.</strong> Model Assembly</a></li></ol></li><li class="chapter-item expanded "><a href="using/checking.html"><strong aria-hidden="true">4.</strong> Checking Models</a></li><li class="chapter-item expanded "><a href="using/cargo.html"><strong aria-hidden="true">5.</strong> Cargo Integration</a></li><li class="chapter-item expanded "><a href="extending/extending.html"><strong aria-hidden="true">6.</strong> Extending Atelier</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="extending/file_io.html"><strong aria-hidden="true">6.1.</strong> Adding an Artifact Representation</a></li><li class="chapter-item expanded "><a href="extending/linter.html"><strong aria-hidden="true">6.2.</strong> Adding a Linter</a></li><li class="chapter-item expanded "><a href="extending/validator.html"><strong aria-hidden="true">6.3.</strong> Adding a Validator</a></li><li class="chapter-item expanded "><a href="extending/transformer.html"><strong aria-hidden="true">6.4.</strong> Adding a Model Transformation</a></li></ol></li><li class="chapter-item expanded "><a href="reference/java_to_rust.html"><strong aria-hidden="true">7.</strong> Appendix: Java/Rust Differences</a></li><li class="chapter-item expanded "><a href="reference/rdf.html"><strong aria-hidden="true">8.</strong> Appendix: RDF Mapping</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/rdf-model.html"><strong aria-hidden="true">8.1.</strong> Models</a></li><li class="chapter-item expanded "><a href="reference/rdf-shapes.html"><strong aria-hidden="true">8.2.</strong> Shapes</a></li><li class="chapter-item expanded "><a href="reference/rdf-traits-values.html"><strong aria-hidden="true">8.3.</strong> Traits and Values</a></li><li class="chapter-item expanded "><a href="reference/rdf-example.html"><strong aria-hidden="true">8.4.</strong> Example</a></li></ol></li><li class="chapter-item expanded "><a href="reference/testing.html"><strong aria-hidden="true">9.</strong> Appendix: Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/line-oriented-writer.html"><strong aria-hidden="true">9.1.</strong> LineOrientedWriter</a></li><li class="chapter-item expanded "><a href="reference/test-crate.html"><strong aria-hidden="true">9.2.</strong> The test Crate</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Atelier — Smithy for Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/johnstonskj/rust-atelier" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>The <a href="https://rust-atelier.dev">Atelier</a> project is a suite of Rust crates that provides the ability 
to read, write, and process AWS <a href="https://awslabs.github.io/smithy/">Smithy</a> interface definition models. AWS is using 
Smithy extensively to define their services and to generate client and server implementations. </p>
<pre><code class="language-smithy">$version: &quot;1.0&quot;

namespace example.motd

@documentation(&quot;Provides a Message of the day.&quot;)
service MessageOfTheDay {
   version: &quot;2020-06-21&quot;
   resources: [
      Message
   ]
}

resource Message {
   identifiers: {
      date: Date
   }
   read: GetMessage
}

@readonly
operation GetMessage {
   input: GetMessageInput
   output: GetMessageInput
}

@pattern(&quot;^\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d$&quot;)
string Date

structure GetMessageInput {
   date: example.motd#Date
}

structure GetMessageOutput {
   @required
   message: String
}
</code></pre>
<p>The goal of the Atelier project is to provide both Rust-native crates that allow parsing and emitting of Smithy models
but also a clean-slate implementation of the Smithy specifications. This aspect has been useful, addressing ambiguities 
in the published documentation.</p>
<p>After a more detailed description of <a href="introduction/smithy.html">Smithy</a> itself, and a tour of the <a href="introduction/crates.html">Atelier crates</a> this book
will cover the following topics:</p>
<ul>
<li>How to programmatically create and manipulate in-memory models.</li>
<li>How to read and write Smithy model files, including assembling in-memory models from multiple source files.</li>
<li>How to use the lint and validate framework to check models.</li>
<li>How to run the <code>cargo-atelier</code> tool to perform many of these actions from the command-line.</li>
<li>How to extend the Atelier provided tools.</li>
</ul>
<h1><a class="header" href="#smithy-overview" id="smithy-overview">Smithy Overview</a></h1>
<p><a href="https://awslabs.github.io/smithy/">Smithy</a> is effectively a framework consisting of a semantic model, a custom IDL language, a mapping to/from JSON, and a 
build process. The semantic model is therefore consistent across different representations allowing different 
representations to be used for human readability as well as machine/tool usage. </p>
<blockquote>
<p><em>Smithy</em> is an interface definition language and set of tools that allows developers to build clients and servers in multiple languages. Smithy models define a service as a collection of resources, operations, and shapes. A Smithy model enables API providers to generate clients and servers in various programming languages, API documentation, test automation, and example code.</p>
</blockquote>
<p>Figures in this section use a combined ER notation to denote cardinality alongside UML inheritance relationships as needed.</p>
<h2><a class="header" href="#framework" id="framework">Framework</a></h2>
<p>The following figure demonstrates the framework elements and their relations.</p>
<p><a name="fig_1_1"></a><img src="introduction/img/smithy-model-concept.svg" alt="Smithy Conceptual Model" /></p>
<div class="caption figure">1.1: Smithy Conceptual Model</div>
<ul>
<li><strong>Semantic Model</strong>; is the in-memory model used by tool. The semantic model has no file or format details associated with it, it may be serialized using a representation into a model file.</li>
<li><strong>Representation</strong>; is a particular model file format such as the Smithy IDL or JSON AST.</li>
<li><strong>Mapping</strong>; is a set of rules that allow for reading and writing a representation. Some representations may not provide a meaningful mapping for read or write.</li>
<li><strong>Artifact</strong>; typically a file on the file system, in a particular representation. A single model is serialized into one, or more, artifacts potentially with different representations.</li>
</ul>
<p>The build process takes multiple model files, validates them, and combines them into a single instance of the semantic model. The process may also perform model transformations to add or remove shapes and metadata before any final artifact generation. </p>
<p>Artifacts may represent different parts of the IDL for a given application but also their dependencies thus enabling the sharing of common shapes. Most tools will only ever deal with the semantic model interfaces with serialization and deserialization simply handled by representation mappings.</p>
<h3><a class="header" href="#transformations" id="transformations">Transformations</a></h3>
<p>The build process mentioned above takes advantage of a number of transformations and while the term process is useful in the build sense the following transformation terms are more specific.</p>
<ul>
<li><em>model-to-model</em>; the act of creating one output model from one or more input model, such as a projection to select only certain shapes from the input model(s).</li>
<li><em>model-to-artifact</em>; the act of creating model files, <em>or</em> generating code or infrastructure artifacts.</li>
<li><em>artifact-to-model</em>; the act of creating a model from one or more model files or other artifacts such as an OpenAPI file.</li>
</ul>
<p>The following figure shows that a transform has to have one or more models and may have zero or more artifacts.</p>
<p><a name="fig_1_2"></a><img src="introduction/img/smithy-model-transforms.svg" alt="Transformations" /></p>
<div class="caption figure">1.2: Transformations</div>
<h2><a class="header" href="#the-semantic-model" id="the-semantic-model">The Semantic Model</a></h2>
<p>The semantic model is a specified in-memory model used by tools. It consists of a set of shapes that corresponds to the data and behavioral elements of a service. </p>
<p><a name="fig_1_3"></a><img src="introduction/img/smithy-model-model.svg" alt="The Semantic Model" /></p>
<div class="caption figure">1.3: The Semantic Model</div>
<ul>
<li><strong>Semantic Model</strong>; a container of shapes and optional <a href="introduction/smithy.html#values">metadata</a>.</li>
<li><strong>Shape</strong>; a defined thing, shapes are either <em>simple</em>, <em>aggregate</em> or <em>service</em> types as described <a href="introduction/smithy.html#shapes">below</a>.</li>
<li><strong>Applied Trait</strong>; <a href="introduction/smithy.html#traits">traits</a> are a meta feature that allows for values to be associated with shapes. Tools may use applied traits for additional validation and code generation.</li>
<li><strong>ShapeID</strong>; the identifier for all shapes defined in a model, all members of defined shapes, and the names of all traits.</li>
</ul>
<h3><a class="header" href="#shape-ids" id="shape-ids">Shape IDs</a></h3>
<p>The shape identifier is a key element of the semantic model and representations. From the Smithy spec:</p>
<blockquote>
<p><em>A shape identifier is used to identify and connect shapes. Every shape in the model is assigned a shape ID which can be referenced by other parts of the model like member targets, resource bindings, operation bindings, and traits. All shape identifiers in the semantic model must be absolute identifiers (that is, they include a shape name and namespace)</em>.</p>
</blockquote>
<p><a name="fig_1_4"></a><img src="introduction/img/smithy-model-shapeid.svg" alt="Shape IDs" /></p>
<div class="caption figure">1.4: Shape IDs</div>
<p>Shape ID has three query methods, <code>is_absolute</code> is true if the id has a namespace; <code>is_relative</code> is true if the id <em>does not</em> have a namespace; and <code>is_member</code> returns true if the id has a member name. It also has four conversion methods, <code>to_absolute</code> returns a new id with the shape name and any member name intact but with the provided namespace; <code>to_relative</code> returns a new id with the shape name and any member name intact but any previous namespace is removed; <code>to_member</code> returns a new id with the namespace and any shape name intact but with the provided member name; and <code>to_shape</code> returns a new id with the namespace and any shape name intact but any previous member name is removed.</p>
<h2><a class="header" href="#shapes" id="shapes">Shapes</a></h2>
<p>Shapes come in three kinds; <em>simple</em>, <em>aggregate</em>, and <em>service</em>. A simple shape is the type for an atomic or primitive value such as <code>integer</code> or <code>string</code>. Aggregate shapes have members such as a <code>list</code> of <code>string</code>s or an address <code>structure</code>. Service shapes have specific semantics, unlike the very generic simple and aggregate shapes, as they represent either a <em>service</em>, a <em>resource</em> managed by a service, or <em>operations</em> on services and resources.</p>
<p><a name="fig_1_5"></a><img src="introduction/img/smithy-model-shapes.svg" alt="Shapes" /></p>
<div class="caption figure">1.5: Shapes</div>
<p>Note that the inheritance relationships in this model are not necessary to implement the semantic model semantics but do make it more understandable.</p>
<h3><a class="header" href="#members" id="members">Members</a></h3>
<p>The aggregate types <em>list</em>, <em>set</em>, <em>map</em>, <em>structure</em>, and <em>union</em> all reference a Member type. This type is shown below, but basically it allows for an identifier as well as a set of traits to be applied to the aggregate type’s components.</p>
<p><a name="fig_1_6"></a><img src="introduction/img/smithy-model-members.svg" alt="Members" /></p>
<div class="caption figure">1.6: Members</div>
<h3><a class="header" href="#traits" id="traits">Traits</a></h3>
<p>Traits in the Smithy IDL look very much like Java annotations, and fulfill a similar role; <em>In the Java computer programming language, an annotation is a form of syntactic metadata that can be added to Java source code.</em> — <em>Wikipedia</em>. However, in Java and other programming languages that support annotations these <em>must</em> be added to the declaration of the source element. In contrast, Smithy allows traits to be <em>applied</em> to a shape in a different artifact or different model entirely.</p>
<p>The term <em>applied trait</em> refers to the usage of a trait either directly or indirectly applied to a shape or member. A <em>trait declaration</em> is simply a simple or aggregate shape declaration with the meta-trait <code>trait</code> applied to it.</p>
<h2><a class="header" href="#values" id="values">Values</a></h2>
<p>There are a few places in the semantic model where data values are used, and the following demonstrates the values supported by the model. </p>
<p><a name="fig_1_7"></a><img src="introduction/img/smithy-model-values.svg" alt="Data Values" /></p>
<div class="caption figure">1.7: Data Values</div>
<ul>
<li><strong>metadata</strong>; every Model has an optional metadata <code>Object</code> which is often used to store tool or process specific values.</li>
<li><strong>node-value</strong>; a trait application has values for the structure that defines the trait itself.</li>
<li><strong>members</strong>; the aggregate values, <code>Array</code> and <code>Object</code>, contain <code>Value</code> members.</li>
</ul>
<p>Note that there is no value type for <code>ShapeID</code>, these are stored in the semantic model as simply strings, their validation happens before the creation of the model and are treated only as opaque values by the model itself.</p>
<h1><a class="header" href="#crate-structure" id="crate-structure">Crate structure</a></h1>
<p>The following figure shows the current set of crates and their dependencies. For most tools it is easiest to simply rely on the <code>lib</code> crate in the same way the <code>cargo</code> crate does in the figure below.</p>
<p><a name="fig_1_8"></a><img src="introduction/img/atelier-crates.svg" alt="Crates" /></p>
<div class="caption figure">1.8: Crates</div>
<ul>
<li><strong>core</strong>; contains the core model and framework elements such as the <code>ModelReader</code>, <code>ModelWriter</code> traits, and <code>Action</code>, <code>Linter</code>, and <code>Validator</code> traits.</li>
<li><strong>assembler</strong>; provides the ability to load multiple files, in supported representations, and merge into a single model.</li>
<li><strong>smithy</strong>; contains implementations of the <code>ModelReader</code> and <code>ModelWriter</code> traits for the Smithy IDL representation.</li>
<li><strong>json</strong>; contains implementations of the <code>ModelReader</code> and <code>ModelWriter</code> traits for the JSON AST representation.</li>
<li><strong>query</strong>;</li>
<li><strong>describe</strong>; contains an implementation of the <code>ModelWriter</code> traits that generates formatted documentation.</li>
<li><strong>rdf</strong>; contains an implementation of the <code>ModelWriter</code> traits for an RDF representation.</li>
<li><strong>openapi</strong>; </li>
<li><strong>lib</strong>;</li>
<li><strong>cargo</strong>; </li>
</ul>
<h1><a class="header" href="#creating-models" id="creating-models">Creating Models</a></h1>
<h1><a class="header" href="#using-the-model-api" id="using-the-model-api">Using the Model API</a></h1>
<p>The following example demonstrates the core model API to create a model for a simple service. The
service, <code>MessageOfTheDay</code> has a single resource <code>Message</code>. The resource has an identifier for the
date, but the <code>read</code> operation does not make the date member required and so will return the message
for the current date.</p>
<p>This API acts as a set of generic data objects and as such has a tendency to be verbose in the
construction of models. The need to create a lot of <code>Identifier</code> and <code>ShapeID</code> instances, for example,
does impact the readability. It is important to note, that while the Smithy
<a href="https://awslabs.github.io/smithy/1.0/spec/core/model.html#shape-id">specification</a> describes
both <em>absolute</em> and <em>relative</em> shape identifiers, relative  identifiers <strong>are not</strong> supported in the semantic 
model. All names in the semantic model <strong>must</strong> be resolved to an absolute name.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use atelier_core::model::identity::{HasIdentity, Identifier};
use atelier_core::model::shapes::{
    HasTraits, MemberShape, Operation, Resource, Service, Shape,
    ShapeKind, Simple, StructureOrUnion, TopLevelShape,
};
use atelier_core::model::values::Value;
use atelier_core::model::{Model, NamespaceID};
use atelier_core::prelude::PRELUDE_NAMESPACE;
use atelier_core::Version;

let prelude: NamespaceID = PRELUDE_NAMESPACE.parse().unwrap();
let namespace: NamespaceID = &quot;example.motd&quot;.parse().unwrap();

// ----------------------------------------------------------------------------------------
let mut date = TopLevelShape::new(
    namespace.make_shape(&quot;Date&quot;.parse().unwrap()),
    ShapeKind::Simple(Simple::String),
);
date
    .apply_with_value(
        prelude.make_shape(&quot;pattern&quot;.parse().unwrap()),
        Value::String(r&quot;^\d\d\d\d\-\d\d-\d\d$&quot;.to_string()).into()
    )
    .unwrap();

// ----------------------------------------------------------------------------------------
let shape_name = namespace.make_shape(&quot;BadDateValue&quot;.parse().unwrap());
let mut body = StructureOrUnion::new();
body.add_member(
    &quot;errorMessage&quot;.parse().unwrap(),
    prelude.make_shape(&quot;String&quot;.parse().unwrap()),
);
let mut error = TopLevelShape::new(shape_name, ShapeKind::Structure(body));
error
    .apply_with_value(
        prelude.make_shape(&quot;error&quot;.parse().unwrap()),
        Some(&quot;client&quot;.to_string().into()),
    )
    .unwrap();

// ----------------------------------------------------------------------------------------
let shape_name = namespace.make_shape(&quot;GetMessageOutput&quot;.parse().unwrap());
let mut output = StructureOrUnion::new();
let mut message = MemberShape::new(
    &quot;message&quot;.parse().unwrap(),
    prelude.make_shape(&quot;String&quot;.parse().unwrap()),
);
message
    .apply(prelude.make_shape(&quot;required&quot;.parse().unwrap()))
    .unwrap();
let _ = output.add_a_member(message);
let output = TopLevelShape::new(
    namespace.make_shape(&quot;GetMessageOutput&quot;.parse().unwrap()),
    ShapeKind::Structure(output),
);

// ----------------------------------------------------------------------------------------
let shape_name = namespace.make_shape(&quot;GetMessageInput&quot;.parse().unwrap());
let mut input = StructureOrUnion::new();
input.add_member(
    &quot;date&quot;.parse().unwrap(),
    date.id().clone(),
);
let input = TopLevelShape::new(
    namespace.make_shape(&quot;GetMessageInput&quot;.parse().unwrap()),
    ShapeKind::Structure(input),
);

// ----------------------------------------------------------------------------------------
let mut get_message = Operation::default();
get_message.set_input_shape(&amp;input);
get_message.set_output_shape(&amp;output);
get_message.add_error_shape(&amp;error);
let mut get_message = TopLevelShape::new(
    namespace.make_shape(&quot;GetMessage&quot;.parse().unwrap()),
    ShapeKind::Operation(get_message),
);
get_message
    .apply(prelude.make_shape(&quot;readonly&quot;.parse().unwrap()))
    .unwrap();

// ----------------------------------------------------------------------------------------
let mut message = Resource::default();
message.add_identifier(Identifier::new_unchecked(&quot;date&quot;), date.id().clone());
message.set_read_operation_shape(&amp;get_message);
let message = TopLevelShape::new(
    namespace.make_shape(&quot;Message&quot;.parse().unwrap()),
    ShapeKind::Resource(message),
);

// ----------------------------------------------------------------------------------------
let mut service = Service::new(&quot;2020-06-21&quot;);
service.add_resource_shape(&amp;message);
let mut service = TopLevelShape::new(
    namespace.make_shape(&quot;MessageOfTheDay&quot;.parse().unwrap()),
    ShapeKind::Service(service),
);
service
    .apply_with_value(
        prelude.make_shape(&quot;documentation&quot;.parse().unwrap()),
        Value::String(&quot;Provides a Message of the day.&quot;.to_string()).into(),
    )
    .unwrap();

// ----------------------------------------------------------------------------------------
let mut model = Model::new(Version::V10);
model.add_shape(message);
model.add_shape(date);
model.add_shape(get_message);
model.add_shape(input);
model.add_shape(output);
model.add_shape(error);

println!(&quot;{:#?}&quot;, model);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#using-the-builder-api" id="using-the-builder-api">Using the Builder API</a></h1>
<p>The following example demonstrates the builder interface to create the same service as the example
above. Hopefully this is more readable as it tends to be less repetative, uses  <code>&amp;str</code> for
identifiers, and includes helper functions for common traits for example. It provides this better
<em>construction experience</em> (there are no read methods on builder objects) by compromising two aspects:</p>
<ol>
<li>The API itself is very repetative; this means the same method may be on multiple objects, but
makes it easier to use. For example, you want to add the documentation trait to a shape, so you can:
<ol>
<li>construct a <code>Trait</code> entity using the core model and the <code>Builder::add_trait</code> method,</li>
<li>use the <code>TraitBuilder::documentation</code> method which also takes the string to use as the trait
value and returns a new <code>TraitBuilder</code>, or</li>
<li>use the <code>Builder::documentation</code> method that hides all the details of a trait and just takes
a string.</li>
</ol>
</li>
<li>It hides a lot of the <code>Identifier</code> and <code>ShapeID</code> construction and so any of those calls to
<code>from_str</code> may fail when the code unwraps the result. This means the builder can panic in ways
the core model does not.</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use atelier_core::builder::traits::ErrorSource;
use atelier_core::builder::values::{ArrayBuilder, ObjectBuilder};
use atelier_core::builder::{
    traits, ListBuilder, MemberBuilder, ModelBuilder, OperationBuilder, ResourceBuilder,
    ServiceBuilder, ShapeTraits, SimpleShapeBuilder, StructureBuilder, TraitBuilder,
};
use atelier_core::model::{Identifier, Model, ShapeID};
use atelier_core::Version;
use std::convert::TryInto;

let model: Model = ModelBuilder::new(Version::V10, &quot;example.motd&quot;)
    .service(
        ServiceBuilder::new(&quot;MessageOfTheDay&quot;, &quot;2020-06-21&quot;)
            .documentation(&quot;Provides a Message of the day.&quot;)
            .resource(&quot;Message&quot;)
            .into(),
    )
    .resource(
        ResourceBuilder::new(&quot;Message&quot;)
            .identifier(&quot;date&quot;, &quot;Date&quot;)
            .read(&quot;GetMessage&quot;)
            .into(),
    )
    .simple_shape(
        SimpleShapeBuilder::string(&quot;Date&quot;)
            .apply_trait(traits::pattern(r&quot;^\d\d\d\d\-\d\d-\d\d$&quot;))
            .into(),
    )
    .operation(
        OperationBuilder::new(&quot;GetMessage&quot;)
            .readonly()
            .input(&quot;GetMessageInput&quot;)
            .output(&quot;GetMessageOutput&quot;)
            .error(&quot;BadDateValue&quot;)
            .into(),
    )
    .structure(
        StructureBuilder::new(&quot;GetMessageInput&quot;)
            .member(&quot;date&quot;, &quot;Date&quot;)
            .into(),
    )
    .structure(
        StructureBuilder::new(&quot;GetMessageOutput&quot;)
            .add_member(MemberBuilder::string(&quot;message&quot;).required().into())
            .into(),
    )
    .structure(
        StructureBuilder::new(&quot;BadDateValue&quot;)
            .error_source(ErrorSource::Client)
            .add_member(MemberBuilder::string(&quot;errorMessage&quot;).required().into())
            .into(),
    )
    .try_into().unwrap();
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#model-visitor" id="model-visitor">Model Visitor</a></h1>
<h1><a class="header" href="#reading-and-writing-models" id="reading-and-writing-models">Reading and Writing Models</a></h1>
<h2><a class="header" href="#model-files" id="model-files">Model Files</a></h2>
<h2><a class="header" href="#smithy-representation" id="smithy-representation">Smithy Representation</a></h2>
<h2><a class="header" href="#json-representation" id="json-representation">JSON Representation</a></h2>
<h2><a class="header" href="#rdf-representation" id="rdf-representation">RDF Representation</a></h2>
<h1><a class="header" href="#model-reader" id="model-reader">Model Reader</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const MANIFEST_DIR: &amp;str = env!(&quot;CARGO_MANIFEST_DIR&quot;);

fn test_file_parses(file_name: &amp;str) {
    let mut path = PathBuf::from_str(MANIFEST_DIR).unwrap();
    path.push(format!(&quot;tests/good/{}.smithy&quot;, file_name));
    println!(&quot;{:?}&quot;, path);
    let mut file = File::open(path).unwrap();
    let mut content: Vec&lt;u8&gt; = Vec::default();
    let _ = file.read_to_end(&amp;mut content).unwrap();

    let mut reader = SmithyReader::default();
    let result = read_model_from_string(&amp;mut reader, content);
    let trait_trait = ShapeID::from_str(&quot;smithy.api#trait&quot;).unwrap();
    match result {
        Ok(parsed) =&gt; {
            let mut names = parsed
                .shapes()
                .map(|shape| {
                    format!(
                        &quot;{:&lt;32} -&gt; {}{}&quot;,
                        shape.id(),
                        if shape.has_trait(&amp;trait_trait) {
                            &quot;trait &quot;
                        } else {
                            &quot;&quot;
                        },
                        match shape.body() {
                            ShapeKind::Simple(v) =&gt; v.to_string(),
                            ShapeKind::List(_) =&gt; SHAPE_LIST.to_string(),
                            ShapeKind::Set(_) =&gt; SHAPE_SET.to_string(),
                            ShapeKind::Map(_) =&gt; SHAPE_MAP.to_string(),
                            ShapeKind::Structure(_) =&gt; SHAPE_STRUCTURE.to_string(),
                            ShapeKind::Union(_) =&gt; SHAPE_UNION.to_string(),
                            ShapeKind::Service(_) =&gt; SHAPE_SERVICE.to_string(),
                            ShapeKind::Operation(_) =&gt; SHAPE_OPERATION.to_string(),
                            ShapeKind::Resource(_) =&gt; SHAPE_RESOURCE.to_string(),
                            ShapeKind::Unresolved =&gt; SHAPE_APPLY.to_string(),
                        }
                    )
                })
                .collect::&lt;Vec&lt;String&gt;&gt;();
            names.sort();
            print!(&quot;{:#?}&quot;, names)
        }
        Err(err) =&gt; panic!(err.to_string()),
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#model-writer" id="model-writer">Model Writer</a></h1>
<h1><a class="header" href="#model-assembly" id="model-assembly">Model Assembly</a></h1>
<p>The following is the simple, and most common, method of using the assembler. This uses the
default <code>FileTypeRegistry</code> and will search for all models in the set of paths specified in
the environment variable “<code>SMITHY_PATH</code>“.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use atelier_assembler::ModelAssembler;
use atelier_core::error::Result;
use atelier_core::model::Model;
use std::convert::TryFrom;

let env_assembler = ModelAssembler::default();

let model: Result&lt;Model&gt; = Model::try_from(env_assembler);
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use atelier_assembler::ModelAssembler;
use atelier_core::error::Result;
use atelier_core::model::Model;
use std::convert::TryFrom;

let mut assembler = ModelAssembler::default();

assembler.push_str(&quot;tests/good&quot;);

let model: Result&lt;Model&gt; = Model::try_from(assembler);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#checking-models" id="checking-models">Checking Models</a></h1>
<p>The following example is taken from the Smithy specification discussing
<a href="https://awslabs.github.io/smithy/1.0/spec/core/shapes.html#relative-shape-id-resolution">relative name resolution</a>.
The <code>run_validation_actions</code> function is commonly used to take a list of actions to be performed
on the model in sequence.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use atelier_core::action::validate::{
    run_validation_actions, CorrectTypeReferences
};
use atelier_core::action::Validator;
use atelier_core::builder::{
    ModelBuilder, ShapeTraits, SimpleShapeBuilder, StructureBuilder, TraitBuilder
};
use atelier_core::model::Model;
use atelier_core::Version;

let model: Model = ModelBuilder::new(Version::V10, &quot;smithy.example&quot;)
    .uses(&quot;foo.baz#Bar&quot;)
    .structure(
        StructureBuilder::new(&quot;MyStructure&quot;)
            .member(&quot;a&quot;, &quot;MyString&quot;)
            .member(&quot;b&quot;, &quot;smithy.example#MyString&quot;)
            .member(&quot;d&quot;, &quot;foo.baz#Bar&quot;)
            .member(&quot;e&quot;, &quot;foo.baz#MyString&quot;)
            .member(&quot;f&quot;, &quot;String&quot;)
            .member(&quot;g&quot;, &quot;MyBoolean&quot;)
            .apply_trait(TraitBuilder::new(&quot;documentation&quot;))
            .into(),
    )
    .simple_shape(SimpleShapeBuilder::string(&quot;MyString&quot;))
    .simple_shape(SimpleShapeBuilder::boolean(&quot;MyBoolean&quot;))
    .into();
let result = run_validation_actions(&amp;mut [
        Box::new(CorrectTypeReferences::default()),
    ], &amp;model, false);
<span class="boring">}
</span></code></pre></pre>
<p>This will result in the following list of validation errors. Note that the error is denoted against
shape or member identifier accordingly.</p>
<pre><code class="language-text">[
    ActionIssue {
        reporter: &quot;CorrectTypeReferences&quot;,
        level: Info,
        message: &quot;The simple shape (smithy.example#MyBoolean) is simply a synonym, did you mean to add any constraint traits?&quot;,
        locus: Some(
            ShapeID {
                namespace: NamespaceID(
                    &quot;smithy.example&quot;,
                ),
                shape_name: Identifier(
                    &quot;MyBoolean&quot;,
                ),
                member_name: None,
            },
        ),
    },
    ActionIssue {
        reporter: &quot;CorrectTypeReferences&quot;,
        level: Info,
        message: &quot;The simple shape (smithy.example#MyString) is simply a synonym, did you mean to add any constraint traits?&quot;,
        locus: Some(
            ShapeID {
                namespace: NamespaceID(
                    &quot;smithy.example&quot;,
                ),
                shape_name: Identifier(
                    &quot;MyString&quot;,
                ),
                member_name: None,
            },
        ),
    },
    ActionIssue {
        reporter: &quot;CorrectTypeReferences&quot;,
        level: Warning,
        message: &quot;Structure member's type (foo.baz#MyString) cannot be resolved to a shape in this model.&quot;,
        locus: Some(
            ShapeID {
                namespace: NamespaceID(
                    &quot;smithy.example&quot;,
                ),
                shape_name: Identifier(
                    &quot;MyStructure&quot;,
                ),
                member_name: Some(
                    Identifier(
                        &quot;e&quot;,
                    ),
                ),
            },
        ),
    },
]
</code></pre>
<h1><a class="header" href="#cargo-integration" id="cargo-integration">Cargo Integration</a></h1>
<pre><code class="language-text">&gt; cargo atelier --help
cargo-atelier 0.1.2
Tools for the Smithy IDL.

USAGE:
    cargo-atelier [FLAGS] &lt;SUBCOMMAND&gt;

FLAGS:
    -h, --help        Prints help information
    -n, --no-color    Turn off color in the output
    -V, --version     Prints version information
    -v, --verbose     The level of logging to perform; from off to trace

SUBCOMMANDS:
    convert     Convert model from one representation to another
    help        Prints this message or the help of the given subcommand(s)
    lint        Run standard linter rules on a model file
    validate    Run standard validators on a model file
</code></pre>
<p>Both the lint and validate commands use a common mechanism for printing results and will by default print using a 
colorized output. As different linter and validation rules can be used the <em>reported by</em> row informs you which rule-set
has determined the error.</p>
<h2><a class="header" href="#linter-example" id="linter-example">Linter example</a></h2>
<p>For the following badly formatted Smithy file, in <code>test-models/lint-test.smithy</code>.</p>
<pre><code class="language-smithy">namespace org.example.smithy

@ThisIsNotAGoodName
structure thisIsMyStructure {
    lower: String,
    Upper: String,
    someJSONThing: someUnknownShape,
    OK: Boolean
}

string someUnknownShape

@trait
structure ThisIsNotAGoodName {}
</code></pre>
<p>The following issues will be output when the linter runs.</p>
<pre><code class="language-text">&gt; cargo atelier lint -i test-models/lint-test.smithy

[info] Shape names should conform to UpperCamelCase, i.e. ThisIsMyStructure
	Reported by NamingConventions on/for element `thisIsMyStructure`.

[info] Trait names should conform to lowerCamelCase, i.e. thisIsNotAGoodName
	Reported by NamingConventions on/for element `ThisIsNotAGoodName`.

[info] Member names should conform to lowerCamelCase, i.e. ok
	Reported by NamingConventions on/for element `thisIsMyStructure$OK`.

[info] Member name 'OK' appears to contain a known acronym, consider renaming i.e. ok
	Reported by NamingConventions on/for element `thisIsMyStructure`.

[info] Member names should conform to lowerCamelCase, i.e. someJsonThing
	Reported by NamingConventions on/for element `thisIsMyStructure$someJSONThing`.

[info] Member name 'someJSONThing' appears to contain a known acronym, consider renaming i.e. Json
	Reported by NamingConventions on/for element `thisIsMyStructure`.

[info] Shape names should conform to UpperCamelCase, i.e. SomeUnknownShape
	Reported by NamingConventions on/for element `someUnknownShape`.

[info] Member names should conform to lowerCamelCase, i.e. upper
	Reported by NamingConventions on/for element `thisIsMyStructure$Upper`.
</code></pre>
<h2><a class="header" href="#validation-example" id="validation-example">Validation example</a></h2>
<p>For the following erroneous Smithy file, in <code>test-models/validation-test.smithy</code>.</p>
<pre><code class="language-smithy">namespace org.example.smithy

structure MyStructure {
    known: String,
    wrongType: SomeOperation,
}

operation SomeOperation {
    input: SomeService
}

service SomeService {
    version: &quot;1.0&quot;,
    operations: [MyStructure]
}
</code></pre>
<p>The following issues will be output when the validation runs.</p>
<pre><code class="language-text">&gt; cargo atelier validate -i test-models/validation-test.smithy

[error] Structure member may not refer to a service, operation, resource or apply.
	Reported by CorrectTypeReferences on/for element `MyStructure$wrongType`.

[warning] Structure member's type (smithy.api#NotString) cannot be resolved to a shape in this model.
	Reported by CorrectTypeReferences on/for element `MyStructure$unknown`.

[error] Service operation must be an operation.
	Reported by CorrectTypeReferences on/for element `SomeService`.

[error] Operation input may not refer to a service, operation, resource or apply.
	Reported by CorrectTypeReferences on/for element `SomeOperation`.
</code></pre>
<h1><a class="header" href="#parameters" id="parameters">Parameters</a></h1>
<p>Common parameters that may be included with any command.</p>
<ul>
<li><code>-V</code>, <code>--version</code>; prints version information (and exits).</li>
<li><code>-h</code>, <code>--help</code>; prints help information (and exits).</li>
<li><code>-v</code>, <code>--verbose</code>; turn on more logging, the more times you add the parameter the more logging you get.</li>
<li><code>--no-color</code>; turn off color support.</li>
</ul>
<p>The following parameters are supported for all file input. File input uses the
<a href="https://github.com/johnstonskj/rust-atelier//atelier-assembler"><code>atelier_assembler</code></a> crate to read multiple files and
support multiple file representations. By default, the model assembler does not use a search path to load files. However,
this can be changed with either the <code>-d</code> flag which will load any files found in the search path in the environment
variable <code>$SMITHY_PATH</code>. Alternatively the <code>-s</code> parameter provides the name of an environment variable to use instead
of <code>$SMITHY_PATH</code>.</p>
<ul>
<li><code>-d</code>, <code>--default-search-env</code>; if set, the standard <code>SMITHY_PATH</code> environment variable will be used as a search path.</li>
<li><code>-i</code>, <code>--in-file &lt;in-file&gt;</code>;the name of a file to read, multiple files can be specified.</li>
<li><code>-s</code>, <code>--search-env &lt;search-env&gt;</code>; the name of an environment variable to use as a search path.</li>
</ul>
<p>The following parameters are supported for all file output.</p>
<ul>
<li><code>-n</code>, <code>--namespace &lt;namespace&gt;</code>;a namespace to write, if the output format requires one.</li>
<li><code>-o</code>, <code>--out-file &lt;out-file&gt;</code>; the name of a file to write to or stdout.</li>
<li><code>-w</code>, <code>--write-format &lt;write-format&gt;</code>; the representation of the output file, the default is dependent on the command.</li>
</ul>
<h1><a class="header" href="#extending-atelier" id="extending-atelier">Extending Atelier</a></h1>
<h1><a class="header" href="#adding-an-artifact-representation" id="adding-an-artifact-representation">Adding an Artifact Representation</a></h1>
<h1><a class="header" href="#model-writer-1" id="model-writer-1">Model Writer</a></h1>
<p>The example below is pretty much the implementation of the <code>atelier_core::io::debug</code> module, it writes the model
using the <code>Debug</code> implementation associated with those objects.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use atelier_core::io::ModelWriter;
use atelier_core::model::Model;
use atelier_core::error::Result as ModelResult;
use std::io::Write;

#[derive(Debug)]
pub struct FooWriter {}

impl Default for FooWriter {
    fn default() -&gt; Self {
        Self {}
    }
}

impl ModelWriter for FooWriter {
    fn write(&amp;mut self, w: &amp;mut impl Write, model: &amp;Model) -&gt; ModelResult&lt;()&gt; {
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#add-transform-function" id="add-transform-function">Add transform function</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn model_to_foo(source: &amp;Model) -&gt; Result&lt;Foo&gt; {
    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl ModelWriter for FooWriter {
    fn write(&amp;mut self, w: &amp;mut impl Write, model: &amp;Model) -&gt; ModelResult&lt;()&gt; {
        let foo = model_to_foo(model)?;
        write!(w, &quot;{}&quot;, foo)?;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#model-reader-1" id="model-reader-1">Model Reader</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use atelier_core::io::ModelReader;
use atelier_core::model::Model;
use atelier_core::error::Result as ModelResult;
use std::io::Write;

#[derive(Debug)]
pub struct FooReader {}

impl Default for FooReader {
    fn default() -&gt; Self {
        Self {}
    }
}

impl ModelReader for FooReader {
    fn read(&amp;mut self, r: &amp;mut impl Read) -&gt; ModelResult&lt;Model&gt; {
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#add-transform-function-1" id="add-transform-function-1">Add transform function</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn pub fn parse_model(r: &amp;mut impl Read) -&gt; ModelResult&lt;Model&gt; {
    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl ModelReader for FooReader {
    fn read(&amp;mut self, r: &amp;mut impl Read) -&gt; ModelResult&lt;Model&gt; {
        parse_model(r)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#adding-a-linter" id="adding-a-linter">Adding a Linter</a></h1>
<h1><a class="header" href="#adding-a-validator" id="adding-a-validator">Adding a Validator</a></h1>
<h1><a class="header" href="#adding-a-model-transformation" id="adding-a-model-transformation">Adding a Model Transformation</a></h1>
<h1><a class="header" href="#java--rust-implementation-differences" id="java--rust-implementation-differences">Java &amp; Rust Implementation Differences</a></h1>
<p>The following, for reference, is a combined view of the semantic model from the <a href="reference/../introduction/smithy.html">Smithy Overview</a>.
Clearly this view is language-neutral and is unlikely to produce an idiomatic interface if implemented as-is.</p>
<p><a name="fig_A_1"></a><img src="reference/img/uml-all.svg" alt="Semantic Model" /></p>
<div class="caption figure">A.1: The Combined Semantic Model</div>
<h2><a class="header" href="#the-java-model" id="the-java-model">The Java Model</a></h2>
<p>The Java model includes a number of additional abstract classes to take advantage of implementation inheritance provided by the Java object model. </p>
<p><a name="fig_A_2"></a><img src="reference/img/smithy-java.svg" alt="Java Implementation" /></p>
<div class="caption figure">A.2: Java Implementation</div>
<p>Points of interest:</p>
<ol>
<li><code>MemberShape</code> and all the model shapes share a common <code>Shape</code> base class.</li>
<li>The <code>ShapeType</code> and <code>NodeType</code> enumerations allow for type determination between shapes and nodes at runtime.</li>
<li>The use of Java’s <code>Number</code> class allows for a wide range of concrete numeric types.</li>
</ol>
<h2><a class="header" href="#the-rust-model" id="the-rust-model">The Rust model</a></h2>
<p>The corresponding Ruse model on the other hand makes little use of inheritance, except for a few traits, but makes use of enumerations instead.</p>
<p><a name="fig_A_3"></a><img src="reference/img/smithy-rust.svg" alt="Rust Implementation" /></p>
<div class="caption figure">A.3: Rust Implementation</div>
<p>Points of interest:</p>
<ol>
<li><code>Node</code> has been renamed as <code>Value</code>, a more approachable and less generic term.</li>
<li><code>TopLevelShape</code> has been introduced as the container type for all non-member shape types.</li>
<li>Neither <code>TopLevelShape</code>, or <code>MemberShape</code>, share a common parent type but do implement the common traits <code>HasIdentity</code>, <code>HasTraits</code>, and <code>NonTraitEq</code>.</li>
<li>The use of Rust enumerations for <code>ShapeKind</code>, <code>Simple</code>, and <code>Value</code> allow for run-time type determination without explicit “Type” values.</li>
<li>The <code>Service::rename</code> and <code>Resource::identifiers</code> values map between <code>ShapeID</code> and <code>Identifier</code> rather than the <code>ShapeID</code> and <code>String</code> used in Java.</li>
<li>Nullable values translate to Rust <code>Option</code> type.</li>
<li>Java <code>List</code> containers translate to Rust <code>Vec</code> containers.</li>
<li>Java <code>Set</code> containers translate to Rust <code>HashSet</code> containers.</li>
<li>Java <code>Map</code> containers translate to Rust <code>HashMap</code> containers.</li>
</ol>
<h3><a class="header" href="#traits-1" id="traits-1">Traits</a></h3>
<p>The Java implementation uses Java service discovery to describe traits as Java classes and apply them to models. There isn’t a direct comparison in Rust to the Java service framework and so traits have to be dealt with in a more static manner (details TBD). </p>
<h3><a class="header" href="#model-operations" id="model-operations">Model Operations</a></h3>
<p>The Java implementation incorporates a number of operations, such as builders, serialization and validation, into the core model which is common for Java. Rust on the other hand tends toward smaller units of packaging and therefore more decoupling of these operations from the model itself. </p>
<p>The <a href="https://crates.io/crates/atelier_core">core crate</a> provides the following modules which are further extended in separate crates.</p>
<ul>
<li><strong>action</strong>; the <code>Action</code>, <code>Linter</code>, <code>Validator</code>, and <code>Transformer</code> traits used to perform the corresponding operations on models. The module also provides some basic lint, transform, and validate implementations.</li>
<li><strong>builder</strong>; a set of builder types providing a more fluent style for model construction.</li>
<li><strong>io</strong>; the <code>ModelReader</code> and <code>ModelWriter</code> traits for implementing serialization of different representations.</li>
<li><strong>model</strong>; just the types necessary to hold the in-memory semantic model.</li>
</ul>
<p>Additionally, the following crates externalize operations.</p>
<ul>
<li><strong><a href="https://crates.io/crates/atelier_assembler">assembler</a></strong> provides model discovery and merge.</li>
<li><strong><a href="https://crates.io/crates/atelier_json">json</a></strong> provides support for the JSON AST representation.</li>
<li><strong><a href="https://crates.io/crates/atelier_smithy">smithy</a></strong> provides support for the Smithy IDL representation.</li>
</ul>
<h1><a class="header" href="#appendix-rdf-mapping" id="appendix-rdf-mapping">Appendix: RDF Mapping</a></h1>
<p>This appendix describes the mapping from Smithy to RDF in detail.</p>
<h2><a class="header" href="#rdf-representation-1" id="rdf-representation-1">RDF Representation</a></h2>
<p>The examples below are shown in the RDF <a href="https://www.w3.org/TR/turtle/">Turtle</a> syntax. The following
namespace prefixes are used:</p>
<pre><code class="language-turtle">@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
@prefix smithy: &lt;https://awslabs.github.io/smithy/rdf-1.0#&gt; .
@prefix api: &lt;urn:smithy:smithy.api:&gt; .
</code></pre>
<ul>
<li><em>rdf</em> - the RDF namespace, used for certain type assertions.</li>
<li><em>xsd</em> - XML Schema data types.</li>
<li><em>smithy</em> - the namespace for the Smithy IDL mapping itself.</li>
<li><em>api</em> - the namespace for the Smithy prelude shapes; this follows the rules in the following section
to generate a URN for the Smithy namespace <code>smithy.api</code>.</li>
</ul>
<h2><a class="header" href="#shape-ids-1" id="shape-ids-1">Shape IDs</a></h2>
<p>To allow for the linking of models in RDF the key identifier in and between models need to be represented
as <a href="https://tools.ietf.org/html/rfc3987">IRI</a>s. This section introduces a Simple URN naming scheme for 
<em>absolute</em> Smithy shape identifiers.</p>
<p>While it is clear that a stable, unique identifier should be used in the same way as the Smithy Shape ID, it
is not at all clear that this needs to carry any location information with it. It would be preferrable to use
the Smithy trait system to associate locations with models rather than forcing location onto all models and 
model elements. The choice of a <a href="https://tools.ietf.org/html/rfc8141">URN</a> over <a href="https://tools.ietf.org/html/rfc3986">URL</a> 
scheme was therefore easier, and provides a clear, human-readable and easily parsed identifier format.</p>
<p>The following rules describe the mapping from Smithy Shape ID to a URN form required by the model and
shape mapping.</p>
<ol>
<li>The URI scheme MUST be exactly <code>urn</code>.</li>
<li>The URN scheme MUST be exactly <code>smithy</code>.</li>
<li>The <em>namespace-specific string</em> (NSS) MUST be formatted as follows.
<ol>
<li>The identifier’s namespace component.</li>
<li>The colon character, <code>':'</code>.</li>
<li>The identifier’s shape name component.</li>
<li><strong>If</strong> the Shape ID represents a member shape:
<ol>
<li>The forward slash character, <code>'/'</code>.</li>
<li>The identifier’s member name component.</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>The following demonstrates this mapping visually.</p>
<pre><code class="language-text">           example.namespace#shape$member
           |---------------| |---| |----|
urn:smithy:example.namespace:shape/member
</code></pre>
<p>The following is a simplified form of the mapping described above.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use atelier_core::model::ShapeID;

fn simple_shapeid_to_urn(shape_id: &amp;ShapeID) -&gt; String {
   format!(
      &quot;urn:smithy:{}:{}{}&quot;,
      shape_id.namespace(),
      shape_id.shape_name(),
      if let Some(member_name) = shape_id.member_name() {
         format!(&quot;/{}&quot;, member_name)
      } else {
         String::new()
      }
   )
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#models" id="models">Models</a></h1>
<ol>
<li>
<p>Each model is an RDF resource, it’s identifier may be an IRI or blank node.</p>
</li>
<li>
<p>The model resource MUST have a property <code>rdf:type</code> with the IRI value <code>smithy:Model</code>.</p>
</li>
<li>
<p>The model resource MUST have a property <code>smithy:smithy_version</code> with a literal string value representing the
Smithy version used to define the model.</p>
<pre><code class="language-turtle">[] 
 a smithy:Model ;
 smithy:smithy_version &quot;1.0&quot; .
</code></pre>
</li>
<li>
<p><strong>ForEach</strong> shape in the model the model resource MUST have a property, named <code>smithy:metadata</code> with a value 
which is the identifier of a top-level shape resource.</p>
<pre><code class="language-turtle">[] 
  a smithy:Model ;
  smithy:smithy_version &quot;1.0&quot; ;
  smithy:shape &lt;urn:smithy:example.motd:Date&gt; .
</code></pre>
</li>
<li>
<p>The model resource MAY have a property, named <code>smithy:metadata</code> that is treated as an <em>Object value</em> and 
generated according to the <a href="reference/rdf-traits-values.html#values">Value</a> rules.</p>
<pre><code class="language-turtle">[] 
  a smithy:Model ;
  smithy:smithy_version &quot;1.0&quot; ;
  smithy:shape &lt;urn:smithy:example.motd:Date&gt; ;
  smithy:metadata [
    a rdf:Bag
    rdf:_1 [
      smithy:key &quot;domain&quot; ;
      smithy:value &quot;identity&quot; ;
    ]
  ] .
</code></pre>
</li>
</ol>
<h1><a class="header" href="#shapes-1" id="shapes-1">Shapes</a></h1>
<ol>
<li>Each <em>top-level</em> shape is an RDF resource, it’s identifier is the URN form of the shape’s <strong>Shape ID</strong>.</li>
<li>The shape resource MUST have a property <code>rdf:type</code> that denotes it’s Smithy type.</li>
<li>The shape resource MAY have applied traits, see later for details.</li>
<li>Aggregate and Service shapes have members, these <em>member</em> shapes have a common set of rules.</li>
<li>All <em>top-level</em> and <em>member</em> shape resource MAY have <a href="reference/rdf-traits-values.html#traits">applied traits</a>.</li>
</ol>
<h2><a class="header" href="#member-shapes" id="member-shapes">Member Shapes</a></h2>
<ol>
<li>Each <em>member</em> shape is an RDF resource, it’s identifier is the URN form of the shape’s <strong>Shape ID</strong>.</li>
<li>The shape resource MUST have a property <code>rdf:type</code> with a value which is the identifier of a <em>top-level</em> shape 
resource.</li>
<li>The shape resource MUST have a property <code>smithy:name</code> with a value which is a literal string for the
name of this member, this value must be a valid identifier.</li>
</ol>
<pre><code class="language-turtle">motd:GetMessageInput
  a smithy:Structure ;
  smithy:member [
    a motd:Date ;
    smithy:name &quot;date&quot;
  ] .
</code></pre>
<h2><a class="header" href="#simple-shapes" id="simple-shapes">Simple shapes</a></h2>
<p>No additional rules.</p>
<pre><code class="language-turtle">&lt;urn:smithy:example.motd:Date&gt; a smithy:String .
</code></pre>
<h3><a class="header" href="#list-shapes" id="list-shapes">List shapes</a></h3>
<ol>
<li>The shape resource MUST have a property <code>rdf:type</code> with the IRI value <code>smithy:List</code>.</li>
<li>The shape resource MUST have a <em>member</em> shape with the name “member”.</li>
</ol>
<pre><code class="language-turtle">&lt;urn:smithy:example.motd:Messages&gt; 
  a smithy:List ;
  smithy:member [
    a smithy:String ;
    smithy:name &quot;member&quot;
  ] .
</code></pre>
<h3><a class="header" href="#set-shapes" id="set-shapes">Set shapes</a></h3>
<ol>
<li>The shape resource MUST have a property <code>rdf:type</code> with the IRI value <code>smithy:Set</code>.</li>
<li>The shape resource MUST have a <em>member</em> shape with the name “member”.</li>
</ol>
<pre><code class="language-turtle">&lt;urn:smithy:example.motd:Messages&gt; 
  a smithy:Set ;
  smithy:member [
    a smithy:String ;
    smithy:name &quot;member&quot;
  ] .
</code></pre>
<h3><a class="header" href="#map-shapes" id="map-shapes">Map shapes</a></h3>
<ol>
<li>The shape resource MUST have a property <code>rdf:type</code> with the IRI value <code>smithy:Map</code>.</li>
<li>The shape resource MUST have a <em>member</em> shape with the name “key”.</li>
<li>The shape resource MUST have a <em>member</em> shape with the name “value”.</li>
</ol>
<pre><code class="language-turtle">&lt;urn:smithy:example.motd:Messages&gt; 
  a smithy:Map ;
  smithy:member [
    a &lt;urn:smithy:example.motd:Language&gt; ;
    smithy:name &quot;key&quot;
  ] ;
  smithy:member [
    a smithy:String ;
    smithy:name &quot;value&quot;
  ] .
</code></pre>
<h3><a class="header" href="#structure-shapes" id="structure-shapes">Structure shapes</a></h3>
<ol>
<li>The shape resource MUST have a property <code>rdf:type</code> with the IRI value <code>smithy:Structure</code>.</li>
<li>The shape resource MAY have any number of <em>member</em> shapes.</li>
</ol>
<pre><code class="language-turtle">&lt;urn:smithy:example.motd:MessageResponse&gt; 
  a smithy:Structure ;
  smithy:member [
    a smithy:String ;
    smithy:name &quot;language&quot;
  ] ;
  smithy:member [
    a smithy:String ;
    smithy:name &quot;message&quot;
  ] .
</code></pre>
<h3><a class="header" href="#union-shapes" id="union-shapes">Union shapes</a></h3>
<ol>
<li>The shape resource MUST have a property <code>rdf:type</code> with the IRI value <code>smithy:Structure</code>.</li>
<li>The shape resource MAY have any number of <em>member</em> shapes.</li>
</ol>
<pre><code class="language-turtle">&lt;urn:smithy:example.motd:MessageResponse&gt; 
  a smithy:Union ;
  smithy:member [
    a smithy:Integer ;
    smithy:name &quot;messageCode&quot;
  ] ;
  smithy:member [
    a smithy:String ;
    smithy:name &quot;message&quot;
] .
</code></pre>
<h3><a class="header" href="#operation-shapes" id="operation-shapes">Operation shapes</a></h3>
<ol>
<li>The shape resource MUST have a property <code>rdf:type</code> with the IRI value <code>smithy:Operation</code>.</li>
<li>The shape resource MAY have a property, named <code>smithy:input</code> with a value which is the identifier
of a top-level shape resource.</li>
<li>The shape resource MAY have a property, named <code>smithy:output</code> with a value which is the identifier
of a top-level shape resource.</li>
<li>The shape resource MAY have any number of properties, named <code>smithy:error</code> with a value which is the 
identifier of a top-level shape resource.</li>
</ol>
<pre><code class="language-turtle">&lt;urn:smithy:example.motd:GetMessage&gt;
  a smithy:Operation ;
  smithy:input &lt;urn:smithy:example.motd:GetMessageRequest&gt; ;
  smithy:output &lt;urn:smithy:example.motd:GetMessageResponse&gt; ;
  smithy:error &lt;urn:smithy:example.motd:BadDateValue&gt; .
</code></pre>
<h3><a class="header" href="#resource-shapes" id="resource-shapes">Resource shapes</a></h3>
<ol>
<li>The shape resource MUST have a property <code>rdf:type</code> with the IRI value <code>smithy:Resource</code>.</li>
<li>The shape resource MAY have a property, named <code>smithy:identifiers</code> with a blank node value.
<ol>
<li>This blank node MUST have a property <code>rdf:type</code> with the IRI value <code>rdf:Bag</code>.</li>
<li>Each property of this blank node follows the standard method to generate predicate names of the
form <code>rdf:_{n}</code> with a blank node value.
<ol>
<li>This blank node MUST have a property <code>smithy:key</code> with a literal string value representing the
identifier item’s key.</li>
<li>This blank node MUST have a property <code>smithy:target</code> with a value which is the identifier
of a top-level shape resource.</li>
</ol>
</li>
</ol>
</li>
<li>The shape resource MAY have a property, named <code>smithy:create</code> with a value which is the identifier
of a top-level shape resource.</li>
<li>The shape resource MAY have a property, named <code>smithy:put</code> with a value which is the identifier
of a top-level shape resource.</li>
<li>The shape resource MAY have a property, named <code>smithy:read</code> with a value which is the identifier
of a top-level shape resource.</li>
<li>The shape resource MAY have a property, named <code>smithy:update</code> with a value which is the identifier
of a top-level shape resource.</li>
<li>The shape resource MAY have a property, named <code>smithy:delete</code> with a value which is the identifier
of a top-level shape resource.</li>
<li>The shape resource MAY have a property, named <code>smithy:list</code> with a value which is the identifier of a shape resource.</li>
<li>The shape resource MAY have any number of properties, named <code>smithy:operation</code> with a value which is the
identifier of a top-level shape resource.</li>
<li>The shape resource MAY have any number of properties, named <code>smithy:collectionOperation</code> with a value which is the
identifier of a top-level shape resource.</li>
<li>The shape resource MAY have any number of properties, named <code>smithy:resource</code> with a value which is the
identifier of a top-level shape resource.</li>
</ol>
<pre><code class="language-turtle">weather:Forecast
  a smithy:Resource ;
  smithy:identifiers [
    a rdf:Bag ;
    rdf:_1 [
      smithy:key &quot;forecastId&quot; ;
      smithy:target weather:ForecastId
    ]
  ] ;
  smithy:read weather:GetForecast .
</code></pre>
<h3><a class="header" href="#service-shapes" id="service-shapes">Service shapes</a></h3>
<ol>
<li>The shape resource MUST have a property <code>rdf:type</code> with the IRI value <code>smithy:Service</code>.</li>
<li>The shape resource MUST have a property <code>smithy:version</code> with a literal,
non-empty, string value.</li>
<li>The shape resource MAY have any number of properties, named <code>smithy:operation</code> with a value which is the
identifier of a top-level shape resource.</li>
<li>The shape resource MAY have any number of properties, named <code>smithy:resource</code> with a value which is the
identifier of a top-level shape resource.</li>
<li>The shape resource MAY have a property, named <code>smithy:rename</code> with a blank node value.
<ol>
<li>This blank node MUST have a property <code>rdf:type</code> with the IRI value <code>rdf:Bag</code>.</li>
<li>Each property of this blank node follows the standard method to generate predicate names of the
form <code>rdf:_{n}</code> with a blank node value.
<ol>
<li>This blank node MUST have a property <code>smithy:shape</code> with a value which is the identifier
of a top-level shape resource.</li>
<li>This blank node MUST have a property <code>smithy:name</code> with a literal string value.</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code class="language-turtle">example:MyService
  a smithy:Service ;
  smithy:version &quot;2017-02-11&quot; ;
  smithy:operations [
    a rdf:Bag ;
    rdf:_1 example:GetSomething
  ] ;
  smithy:rename [
    a rdf:Bag ;
    rdf:_1 [
      smithy:shape &lt;urn:smithy:foo.example:Widget&gt; ;
      smithy:name &quot;FooWidget&quot;
    ]
  ] .
</code></pre>
<h1><a class="header" href="#traits-and-values" id="traits-and-values">Traits and Values</a></h1>
<h2><a class="header" href="#traits-2" id="traits-2">Traits</a></h2>
<p>Any shape, either a <em>top-level</em>, or a <em>member</em>, may have traits applied and these are represented as
follows.</p>
<ol>
<li>The shape resource MAY have any number of properties, named <code>smithy:apply</code> with a blank node value.
<ol>
<li>This blank node MUST have a property <code>smithy:trait</code> with a value which is the identifier
of a <em>top-level</em> shape resource.</li>
<li>This blank node MAY have a property <code>smithy:value</code> representing the trait parameter value -
see <a href="reference/rdf-traits-values.html#values">Value</a> production rules later.</li>
</ol>
</li>
</ol>
<p>The following example shows traits applied to a <em>top-level</em> shape.</p>
<pre><code class="language-turtle">motd:BadDateValue
  a smithy:Structure ;
  smithy:apply [
    smithy:trait api:error ;
    smithy:value &quot;client&quot;
  ] .
</code></pre>
<p>The following example shows traits applied to a <em>member</em> shape.</p>
<pre><code class="language-turtle">&lt;urn:smithy:example.motd:BadDateValue/errorMessage&gt; 
  a smithy:Member ;
  smithy:target smithy:String ;
  smithy:apply [
    smithy:trait api:required
  ] .
</code></pre>
<h2><a class="header" href="#values-1" id="values-1">Values</a></h2>
<p>Values are are used in both the model metadata section,</p>
<pre><code class="language-turtle">smithy:metadata [
  a rdf:Bag
  rdf:_1 [
    smithy:key &quot;domain&quot; ;
    smithy:value &quot;identity&quot; ;
  ]
] .
</code></pre>
<p>as well as in passing parameters to applied traits.</p>
<pre><code class="language-turtle">smithy:apply [
  smithy:trait api:title ;
  smithy:value &quot;My new thing&quot;
] .
</code></pre>
<p>The following define the production rules for values in either of these cases.</p>
<h3><a class="header" href="#strings" id="strings">Strings</a></h3>
<p>String values MAY be represented as unqualified string literals OR as qualified strings with the data type <code>xsd:string</code>.</p>
<pre><code class="language-turtle">[] smithy:value &quot;My new thing&quot; .

[] smithy:value &quot;My new thing&quot;^^xsd:string .
</code></pre>
<h3><a class="header" href="#booleans" id="booleans">Booleans</a></h3>
<p>Boolean values MUST be represented as string literals with the type <code>xsd:boolean</code>.</p>
<pre><code class="language-turtle">[] smithy:value &quot;true&quot;^^xsd:boolean&quot; .

# alternatively, in Turtle:

[] smithy:value true .
</code></pre>
<h3><a class="header" href="#numbers" id="numbers">Numbers</a></h3>
<p>Number values MUST be represented as string literals with either the type <code>xsd:signedLong</code> or
<code>xsd:double</code>.</p>
<pre><code class="language-turtle">[] smithy:value &quot;1&quot;^^xsd:signedLong&quot; .

[] smithy:value &quot;3.14&quot;^^xsd:double&quot; .
</code></pre>
<h3><a class="header" href="#arrays" id="arrays">Arrays</a></h3>
<p>Array values MUST be represented as a new blank node.</p>
<ol>
<li>This node MUST have a property <code>rdf:type</code> with the IRI value <code>rdf:Seq</code>.</li>
<li>Each property of this blank node follows the standard method to generate predicate names of the 
form <code>rdf:_{n}</code> with a <em>value</em> using these same production rules.</li>
</ol>
<pre><code class="language-turtle">smithy:value [
  a rdf:Seq ;
  rdf:_1 &quot;experimental&quot; ;
  rdf:_2 &quot;public&quot;
]
</code></pre>
<h3><a class="header" href="#objects" id="objects">Objects</a></h3>
<p>Object values MUST be represented as a new blank node.</p>
<ol>
<li>This node MUST have a property <code>rdf:type</code> with the IRI value <code>rdf:Bag</code>.</li>
<li>Each property of this blank node follows the standard method to generate predicate names of the
form<code>rdf:_{n}</code> with a blank node value.
<ol>
<li>This node MUST have a property <code>smithy:key</code> with a string literal for the identifier name.</li>
<li>This node MUST have a property <code>smithy:value</code> with a <em>value</em> using these same production rules.</li>
</ol>
</li>
</ol>
<pre><code class="language-turtle">smithy:value [
 a rdf:Bag ;
 rdf:_1 [
   smithy:key &quot;Homepage&quot; ;
   smithy:value &quot;https://www.example.com/&quot; ;
 ] ;
 rdf:_1 [
   smithy:key &quot;API Reference&quot; ;
   smithy:value &quot;https://www.example.com/api-ref&quot; ;
 ] ;
]
</code></pre>
<h3><a class="header" href="#null" id="null">Null</a></h3>
<p>Smithy supports the notion of a null type, this is represented by the specific IRI <code>smithy:null</code>.</p>
<pre><code class="language-turtle">[] smithy:value smithy:null .
</code></pre>
<h1><a class="header" href="#example" id="example">Example</a></h1>
<p>Presented below is the <em>Message of the Day</em> Example with the corresponding Smithy and
RDF sections side by side for comparison. You can download the Turtle <a href="reference/motd.ttl">source file</a> as well.</p>
<table class="plain">
<thead>
<tr>
<th></th> <th> Smithy IDL </th> <th> RDF Representation </th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td style="vertical-align: top;">
</td>
<td style="vertical-align: top;">
<pre><code class="language-turtle">@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
@prefix smithy: &lt;https://awslabs.github.io/smithy/rdf-1.0#&gt; .
@prefix api: &lt;urn:smithy:smithy.api:&gt; .
@prefix : &lt;urn:smithy:example.motd:&gt; .
</code></pre>
</td>
</tr>
<tr>
<td> 2 </td>
<td style="vertical-align: top;">
<pre><code class="language-smithy">$version: &quot;1.0&quot;

namespace example.motd
</code></pre>
</td>
<td style="vertical-align: top;">
<pre><code class="language-turtle">[]
  a smithy:Model ;
  smithy:smithy_version &quot;1.0&quot; ;
  smithy:shape
    :GetMessageOutput ,
    :Message ,
    :GetMessageInput ,
    :BadDateValue ,
    :GetMessage ,
    :MessageOfTheDay ,
    :Date .
</code></pre>
</td>
</tr>
<tr>
<td> 3 </td>
<td style="vertical-align: top;">
<pre><code class="language-smithy">@pattern(
  &quot;^\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d$&quot;
)
string Date
</code></pre>
</td>
<td style="vertical-align: top;">
<pre><code class="language-turtle">:Date
  a smithy:String ;
  smithy:apply [
    smithy:trait api:pattern ;
    smithy:value &quot;^\\d\\d\\d\\d\\-\\d\\d-\\d\\d$&quot;
  ] .
</code></pre>
</td>
</tr>
<tr>
<td> 4 </td>
<td style="vertical-align: top;">
<pre><code class="language-smithy">resource Message {
   identifiers: {
      date: Date
   }
   read: GetMessage
}
</code></pre>
</td>
<td style="vertical-align: top;">
<pre><code class="language-turtle">:Message
  a smithy:Resource ;
  smithy:identifiers [
    a rdf:Bag ;
    rdf:_1 [
      smithy:key &quot;date&quot; ;
      smithy:target :Date
    ]
  ] ;
  smithy:read :GetMessage .
</code></pre>
</td>
</tr>
<tr>
<td> 5 </td>
<td style="vertical-align: top;">
<pre><code class="language-smithy">structure GetMessageInput {
   date: Date
}
</code></pre>
</td>
<td style="vertical-align: top;">
<pre><code class="language-turtle">:GetMessageInput
  a smithy:Structure ;
  smithy:member [
    a :Date ;
    smithy:name &quot;date&quot;^^xsd:string
  ] .
</code></pre>
</td>
</tr>
<tr>
<td> 6 </td>
<td style="vertical-align: top;">
<pre><code class="language-smithy">structure GetMessageOutput {
   @required
   message: String
}
</code></pre>
</td>
<td style="vertical-align: top;">
<pre><code class="language-turtle">:GetMessageOutput
  a smithy:Structure ;
  smithy:member [
    a api:String ;
    smithy:name &quot;message&quot;^^xsd:string ;
    smithy:apply [ smithy:trait api:required ] ;
  ] .
</code></pre>
</td>
</tr>
<tr>
<td> 7 </td>
<td style="vertical-align: top;">
<pre><code class="language-smithy">@error(&quot;client&quot;)
structure BadDateValue {
   @required
   errorMessage: String
}
</code></pre>
</td>
<td style="vertical-align: top;">
<pre><code class="language-turtle">:BadDateValue
  a smithy:Structure ;
  smithy:apply [
    smithy:trait api:error ;
    smithy:value &quot;client&quot;
  ] ;
  smithy:member [
    a api:String ;
    smithy:name &quot;errorMessage&quot;^^xsd:string ;
    smithy:apply [ smithy:trait &lt;urn:smithy:smithy.api:required&gt; ] ;
  ] .
</code></pre>
</td>
</tr>
<tr>
<td> 8 </td>
<td style="vertical-align: top;">
<pre><code class="language-smithy">@readonly
operation GetMessage {
   input: GetMessageInput
   output: GetMessageInput
   errors: [ BadDateValue ]
}
</code></pre>
</td>
<td style="vertical-align: top;">
<pre><code class="language-turtle">:GetMessage
  a smithy:Operation ;
  smithy:input :GetMessageInput ;
  smithy:output :GetMessageOutput ;
  smithy:error :BadDateValue .
</code></pre>
</td>
</tr>
<tr>
<td> 9 </td>
<td style="vertical-align: top;">
<pre><code class="language-smithy">@documentation(
  &quot;Provides a Message of the day.&quot;
)
service MessageOfTheDay {
   version: &quot;2020-06-21&quot;
   resources: [ Message ]
}
</code></pre>
</td>
<td style="vertical-align: top;">
<pre><code class="language-turtle">:MessageOfTheDay
  a smithy:Service ;
  smithy:apply [
    smithy:trait api:documentation ;
    smithy:value &quot;Provides a Message of the day.&quot;
  ] ;
  smithy:version &quot;2020-06-21&quot; ;
  smithy:resource :Message .
</code></pre>
</td>
</tr>
</tbody>
</table>
<h1><a class="header" href="#appendix-testing" id="appendix-testing">Appendix: Testing</a></h1>
<p>Rust has excellent test tools, patterns, and idioms, but where different crates are implementing common traits the tendency is to duplicate tests. To this end the <a href="https://crates.io/crates/atelier_test">test</a> contains common examples with expected results that can be used by different crate implementations. To achieve this the crate leverages a specific write-only representation that is stable in it’s ordering and can be directly diffed between test runs.</p>
<h1><a class="header" href="#the-lineorientedwriter" id="the-lineorientedwriter">The LineOrientedWriter</a></h1>
<p>This representation is such
that it is always ordered and has no whitespace or other ambiguities and so can be directly
compared as a whole. This is valuable for testing but can also be extremely fast for parsing
tools.</p>
<h1><a class="header" href="#example-1" id="example-1">Example</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use atelier_core::io::ModelWriter;
use atelier_core::io::lines::LineOrientedWriter;
use atelier_core::model::Model;
<span class="boring">fn make_model() -&gt; Model { Model::default() }
</span>let model = make_model();

let mut writer = LineOrientedWriter::default();
let result = writer.write(&amp;mut std::io::stdout(), &amp;model);
assert!(result.is_ok())
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#representation-format" id="representation-format">Representation Format</a></h1>
<p>The following is a description of the production of the format.</p>
<pre><code class="language-text">segment-separator = &quot;::&quot; ;
target-operator = &quot;=&gt;&quot; ;
value-assignment-operator = &quot;&lt;=&quot; ;
</code></pre>
<p>The numbers on the left of the lines below are for reference within in the production rule text.</p>
<pre><code class="language-text"> 1. {shape_type}::{shape_id}
 2. {shape_type}::{shape_id}::trait::{shape_id}
 3. {shape_type}::{shape_id}::trait::{shape_id}&lt;={value...}
 4. {shape_type}::{shape_id}::{member_name}=&gt;{target_shape_id}
 5. {shape_type}::{shape_id}::{member_name}::trait::{shape_id}
 6. {shape_type}::{shape_id}::{member_name}::trait::{shape_id}&lt;={value...}
 7. resource::{shape_id}::identifier::{identifier}=&gt;{shape_id}
 8. service::{shape_id}::rename::{shape_id}&lt;={identifier}
 9. meta::{identifier}&lt;={value...}
10. ()
11. {simple_value}
12. [{integer}]&lt;={value...}
13. {{identifier}}&lt;={value...}
</code></pre>
<p><strong>Shape Production Rules</strong></p>
<p>For each top-level shape:</p>
<ul>
<li>emit the name of the shape’s type, a <em>segment-separator</em>, and the shape’s fully qualified name, and a newline (1).</li>
<li>For each trait applied to this shape:
<ul>
<li>append to the above string the value “<code>::trait</code>“, and the trait’s fully qualified name (2),</li>
<li>if the trait has a value, append the <em>value-assignment-operator</em> and follow the value production rules below (3).</li>
<li>finish with a newline.</li>
</ul>
</li>
<li>For each member of the shape:
<ul>
<li>emit a line with the member identifier, the <em>target-operator</em>, and the target’s fully qualified name, and a newline (4),
<ul>
<li>for array-valued members the member name emitted is the singular form with a line per value (error for errors, etc.).</li>
<li>If the shape is a resource; emit the “<code>identifiers</code>“ map-valued member:
<ul>
<li>append an additional “<code>::identifier::</code>“ string,</li>
<li>emit each key followed by the <em>target-operator</em>, and the target’s fully qualified name, and a newline (7),</li>
</ul>
</li>
<li>If the shape is a service; emit the “<code>rename</code>“ map-valued member:
<ul>
<li>append an additional “<code>::rename::</code>“ string,</li>
<li>emit each key (fully qualified shape ID), followed by the <em>value-assignment-operator</em>, and the value (identifier), and a newline (8),</li>
</ul>
</li>
</ul>
</li>
<li>For each trait applied to the member:
<ul>
<li>append to the above string the value “<code>::trait</code>“, and the trait’s fully qualified name (5),</li>
<li>if the trait has a value, append the <em>value-assignment-operator</em> and follow the value production rules below (6).</li>
<li>finish with a newline.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Metadata Production Rules</strong></p>
<p>For each value in the model’s metadata map:</p>
<ul>
<li>use the string “<code>meta</code>“ as if it where a shape name followed by the <em>segment-separator</em>.</li>
<li>append the key name, the <em>value-assignment-operator</em> and follow the value production rules below (9).</li>
</ul>
<p><strong>Value Production Rules</strong></p>
<ul>
<li>For null values simply emit the string <code>&quot;()&quot;</code> (10).</li>
<li>For boolean, numeric, and string values emit their natural form (11).
<ul>
<li>Ensure string values quote the characters <code>'\n'</code>, <code>'\r'</code>, and <code>'&quot;'</code>.</li>
</ul>
</li>
<li>For arrays:
<ul>
<li>emit a line per index, with <code>'['</code>, the index as a zero-based integer, <code>']'</code>, the <em>value-assignment-operator</em>
and follow these same value production rules (12),</li>
<li>an empty array will be denoted by the string <code>&quot;[]&quot;</code>.</li>
</ul>
</li>
<li>For objects:
<ul>
<li>emit a line per key, with <code>&quot;{&quot;</code>, the key name, <code>&quot;}&quot;</code>, the <em>value-assignment-operator</em> and follow
these same value production rules (13),</li>
<li>an empty object MUST be denoted by the string <code>&quot;{}&quot;</code>.</li>
</ul>
</li>
</ul>
<p>Finally, all lines MUST be sorted to ensure the overall output can be compared.</p>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<p>A simple string shape with a trait applied.</p>
<pre><code class="language-text">// &quot;pattern&quot; is a trait.
@pattern(&quot;^[A-Za-z0-9 ]+$&quot;)
string CityId
</code></pre>
<pre><code class="language-text">string::example.weather#CityId
string::example.weather#CityId::trait::smithy.api#pattern&lt;=&quot;^[A-Za-z0-9 ]+$&quot;
</code></pre>
<p>An operation, note the rename of “errors” to “error as the member identifier.</p>
<pre><code class="language-text">@readonly
operation GetCity {
    input: GetCityInput
    output: GetCityOutput
    errors: [NoSuchResource]
}
</code></pre>
<pre><code class="language-text">operation::example.weather#GetCity
operation::example.weather#GetCity::error=&gt;example.weather#NoSuchResource
operation::example.weather#GetCity::input=&gt;example.weather#GetCityInput
operation::example.weather#GetCity::output=&gt;example.weather#GetCityInput
operation::example.weather#GetCity::trait::smithy.api#readonly
</code></pre>
<p>A service, note the object-based trait “paginated” and the comment that has been turned into a
documentation trait.</p>
<pre><code class="language-text">/// Provides weather forecasts.
@paginated(inputToken: &quot;nextToken&quot;, outputToken: &quot;nextToken&quot;,
           pageSize: &quot;pageSize&quot;)
service Weather {
    version: &quot;2006-03-01&quot;
    resources: [City]
    operations: [GetCurrentTime]
    rename: {
        &quot;foo.example#Widget&quot;: &quot;FooWidget&quot;
    }
}
</code></pre>
<pre><code class="language-text">service::example.weather#Weather
service::example.weather#Weather::operation=&gt;example.weather#GetCurrentTime
service::example.weather#Weather::resource=&gt;example.weather#City
service::example.weather#Weather::rename::foo.example#Widget&lt;=FooWidget
service::example.weather#Weather::trait::smithy.api#documentation&lt;=&quot;Provides weather forecasts.&quot;
service::example.weather#Weather::trait::smithy.api#paginated&lt;={inputToken}=&quot;nextToken&quot;
service::example.weather#Weather::trait::smithy.api#paginated&lt;={outputToken}=&quot;nextToken&quot;
service::example.weather#Weather::trait::smithy.api#paginated&lt;={pageSize}=&quot;pageSize&quot;
service::example.weather#Weather::version&lt;=&quot;2006-03-01&quot;
</code></pre>
<h1><a class="header" href="#the-test-crate" id="the-test-crate">The test Crate</a></h1>
<p>The following example (from the smithy crate) shows how the common test crate is used to read a <code>.smithy</code> file, then 
serialize in the line-oriented form and compare to a pre-stored expected result.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use atelier_smithy::SmithyReader;
use atelier_test::parse_and_compare_to_files;
use std::path::PathBuf;

const MANIFEST_DIR: &amp;str = env!(&quot;CARGO_MANIFEST_DIR&quot;);

fn test_file_parses(file_name: &amp;str) {
    let source_file = PathBuf::from(format!(&quot;{}/tests/good/{}.smithy&quot;, MANIFEST_DIR, file_name));
    let expected_file = PathBuf::from(format!(&quot;{}/tests/good/{}.lines&quot;, MANIFEST_DIR, file_name));
    let mut reader = SmithyReader::default();
    parse_and_compare_to_files(&amp;mut reader, &amp;source_file, &amp;expected_file);
}

#[test]
fn test_weather_example() {
    test_file_parses(&quot;weather&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>For more information, see the <a href="https://docs.rs/atelier_test/">crate documentation</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="smithy.js"></script>
        
        <script type="text/javascript" src="turtle.js"></script>
        
        <script type="text/javascript" src="atelier.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
